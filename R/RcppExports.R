# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

vec_to_symmat <- function(x) {
    .Call(`_spamtree_vec_to_symmat`, x)
}

mvCovAG20107x <- function(coords1, qv_block1, coords2, qv_block2, ai1, ai2, phi_i, thetamv, Dmat, same = FALSE) {
    .Call(`_spamtree_mvCovAG20107x`, coords1, qv_block1, coords2, qv_block2, ai1, ai2, phi_i, thetamv, Dmat, same)
}

find_not_nan <- function(infield, filtering) {
    .Call(`_spamtree_find_not_nan`, infield, filtering)
}

list_mean <- function(x) {
    .Call(`_spamtree_list_mean`, x)
}

list_cubes_mean <- function(x, cslice) {
    .Call(`_spamtree_list_cubes_mean`, x, cslice)
}

list_qtile <- function(x, q) {
    .Call(`_spamtree_list_qtile`, x, q)
}

kthresholds <- function(x, k) {
    .Call(`_spamtree_kthresholds`, x, k)
}

col_to_string <- function(X) {
    .Call(`_spamtree_col_to_string`, X)
}

part_axis_parallel_lmt <- function(coords, thresholds) {
    .Call(`_spamtree_part_axis_parallel_lmt`, coords, thresholds)
}

make_edges <- function(parchimat, non_empty_blocks, res_is_ref) {
    .Call(`_spamtree_make_edges`, parchimat, non_empty_blocks, res_is_ref)
}

make_edges_limited <- function(parchimat, non_empty_blocks, res_is_ref) {
    .Call(`_spamtree_make_edges_limited`, parchimat, non_empty_blocks, res_is_ref)
}

number_revalue <- function(original_mat, from_val, to_val) {
    .Call(`_spamtree_number_revalue`, original_mat, from_val, to_val)
}

spamtree_mv_mcmc <- function(y, X, Z, coords, mv_id, blocking, gix_block, res_is_ref, parents, children, limited_tree, layer_names, layer_gibbs_group, indexing, set_unif_bounds_in, start_w, theta, beta, tausq, mcmcsd, mcmc_keep = 100L, mcmc_burn = 100L, mcmc_thin = 1L, num_threads = 1L, use_alg = 'S', adapting = FALSE, verbose = FALSE, debug = FALSE, printall = FALSE, sample_beta = TRUE, sample_tausq = TRUE, sample_theta = TRUE, sample_w = TRUE, sample_predicts = TRUE) {
    .Call(`_spamtree_spamtree_mv_mcmc`, y, X, Z, coords, mv_id, blocking, gix_block, res_is_ref, parents, children, limited_tree, layer_names, layer_gibbs_group, indexing, set_unif_bounds_in, start_w, theta, beta, tausq, mcmcsd, mcmc_keep, mcmc_burn, mcmc_thin, num_threads, use_alg, adapting, verbose, debug, printall, sample_beta, sample_tausq, sample_theta, sample_w, sample_predicts)
}

spamtree_mv_mcmc_devel <- function(y, X, Z, coords, mv_id, blocking, gix_block, res_is_ref, parents, children, limited_tree, layer_names, layer_gibbs_group, indexing_knots, indexing_obs, set_unif_bounds_in, start_w, theta, beta, tausq, mcmcsd, mcmc_keep = 100L, mcmc_burn = 100L, mcmc_thin = 1L, num_threads = 1L, use_alg = 'S', adapting = FALSE, verbose = FALSE, debug = FALSE, printall = FALSE, sample_beta = TRUE, sample_tausq = TRUE, sample_theta = TRUE, sample_w = TRUE, sample_predicts = TRUE) {
    .Call(`_spamtree_spamtree_mv_mcmc_devel`, y, X, Z, coords, mv_id, blocking, gix_block, res_is_ref, parents, children, limited_tree, layer_names, layer_gibbs_group, indexing_knots, indexing_obs, set_unif_bounds_in, start_w, theta, beta, tausq, mcmcsd, mcmc_keep, mcmc_burn, mcmc_thin, num_threads, use_alg, adapting, verbose, debug, printall, sample_beta, sample_tausq, sample_theta, sample_w, sample_predicts)
}

